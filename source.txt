use std::sync::atomic::{AtomicUsize, Ordering};
use meshtastic::protobufs::{FromRadio, mesh_packet::PayloadVariant, PortNum};

use crate::radio_message::{AppMessage, RadioMessage, Telemetry};

static TELEMETRY_COUNT: AtomicUsize = AtomicUsize::new(0);

pub fn handle_from_radio(msg: FromRadio) {
    match RadioMessage::try_from(&msg) {
        Ok(rm) => match &rm.app {
            AppMessage::Telemetry(tel) => {
                // Increment global telemetry counter
                let count = TELEMETRY_COUNT.fetch_add(1, Ordering::SeqCst) + 1;

                // Pattern match on the specific telemetry variant
                match tel {
                    Telemetry::Device {
                        battery_level,
                        voltage,
                        uptime_seconds,
                    } => {
                        log::info!(
                            "Node {} Device Telemetry #{} → Voltage: {:?} V, Battery: {:?} %, Uptime: {:?} s",
                            rm.node_id,
                            count,
                            voltage,
                            battery_level,
                            uptime_seconds
                        );
                    }
                    Telemetry::Environment {
                        temperature,
                        humidity,
                        pressure,
                    } => {
                        log::info!(
                            "Node {} Environment Telemetry #{} → Temp: {:?} °C, Humidity: {:?} %, Pressure: {:?} hPa",
                            rm.node_id,
                            count,
                            temperature,
                            humidity,
                            pressure
                        );
                    }
                    Telemetry::Power { voltage, current } => {
                        log::info!(
                            "Node {} Power Telemetry #{} → Voltage: {:?} V, Current: {:?} A",
                            rm.node_id,
                            count,
                            voltage,
                            current
                        );
                    }
                }
            }
            AppMessage::Position(pos) => {
                log::info!(
                    "Node {} Position → Lat: {:.7}, Lon: {:.7}, Alt: {} m, Accuracy: {} m",
                    rm.node_id,
                    pos.latitude,
                    pos.longitude,
                    pos.altitude,
                    pos.accuracy
                );
            }
            AppMessage::Text(text) => {
                log::info!(
                    "Node {} Text → From: {:?}, To: {:?}, Msg: {}",
                    rm.node_id,
                    text.from,
                    text.to,
                    text.msg
                );
            }
        },
        Err(e) => {
            log::warn!("Failed to parse FromRadio message from node {}: {:?}", msg.id, e);
        }
    }
}
mod handler;
mod playback;
mod radio_message;
mod recording_stream;

use std::env;

use handler::handle_from_radio;
use playback::PlaybackStream;
use recording_stream::RecordingStream;

use meshtastic::api::StreamApi;
use meshtastic::utils;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Debug)
        .filter_module(
            "meshtastic::connections::stream_buffer",
            log::LevelFilter::Error,
        )
        .init();

    let args: Vec<String> = env::args().collect();

    /*
        Usage:

        Live mode (default):
            cargo run
            cargo run -- live

        Record mode:
            cargo run -- record recordings

        Playback mode:
            cargo run -- replay recordings/meshtastic-recording-00000.bin
    */

    match args.get(1).map(String::as_str) {
        Some("replay") => {
            let path = args.get(2).expect("missing replay file path");
            run_playback(path)?;
        }
        Some("record") => {
            let path = args.get(2).expect("missing record file path");
            run_record(path).await?;
        }
        _ => {
            run_live().await?;
        }
    }

    Ok(())
}

/* ---------------- Live Path ---------------- */

async fn run_live() -> Result<(), Box<dyn std::error::Error>> {
    println!("Starting live Meshtastic stream…");

    let stream_api = StreamApi::new();
    let serial_stream =
        utils::stream::build_serial_stream("/dev/ttyACM0".to_string(), None, None, None)?;

    let (mut decoded_listener, stream_api) = stream_api.connect(serial_stream).await;
    let config_id = utils::generate_rand_id();
    let _stream_api = stream_api.configure(config_id).await?;

    while let Some(from_radio) = decoded_listener.recv().await {
        handle_from_radio(from_radio);
    }

    Ok(())
}

/* ---------------- Record Path ---------------- */

async fn run_record(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Recording to: {}", path);

    let mut recorder = RecordingStream::new(path)?;

    let stream_api = StreamApi::new();
    let serial_stream =
        utils::stream::build_serial_stream("/dev/ttyACM0".to_string(), None, None, None)?;

    let (mut decoded_listener, stream_api) = stream_api.connect(serial_stream).await;
    let config_id = utils::generate_rand_id();
    let _stream_api = stream_api.configure(config_id).await?;

    while let Some(from_radio) = decoded_listener.recv().await {
        let raw = meshtastic::Message::encode_to_vec(&from_radio);
        recorder.record(&raw)?;

        handle_from_radio(from_radio);
    }

    recorder.flush()?;
    Ok(())
}

/* ---------------- Playback Path ---------------- */

fn run_playback(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    log::info!("Replaying capture from: {}", path);

    let playback = PlaybackStream::open(path)?;
    log::info!("Playback started");

    for msg in playback {
        let from_radio = msg?;
        //log::info!("Replayed FromRadio: {:?}", from_radio);
        handle_from_radio(from_radio);
    }

    Ok(())
}
use std::fs::File;
use std::io::{self, BufReader, Read};

use meshtastic::protobufs::FromRadio;
use meshtastic::Message;

pub struct PlaybackStream {
    reader: BufReader<File>,
}

impl PlaybackStream {
    pub fn open(path: &str) -> io::Result<Self> {
        Ok(Self {
            reader: BufReader::new(File::open(path)?),
        })
    }
}

impl Iterator for PlaybackStream {
    type Item = io::Result<FromRadio>;

    fn next(&mut self) -> Option<Self::Item> {
    // Read 8-byte timestamp (discard for now)
    let mut ts_buf = [0u8; 8];
    if let Err(e) = self.reader.read_exact(&mut ts_buf) {
        if e.kind() == io::ErrorKind::UnexpectedEof {
            return None;
        } else {
            return Some(Err(e.into()));
        }
    }

    // Now read 4-byte payload length
    let mut len_buf = [0u8; 4];
    if let Err(e) = self.reader.read_exact(&mut len_buf) {
        if e.kind() == io::ErrorKind::UnexpectedEof {
            return None;
        } else {
            return Some(Err(e.into()));
        }
    }

    let len = u32::from_le_bytes(len_buf) as usize;

    let mut buf = vec![0u8; len];
    if let Err(e) = self.reader.read_exact(&mut buf) {
        if e.kind() == io::ErrorKind::UnexpectedEof {
            eprintln!("Warning: truncated frame at end of file");
            return None;
        } else {
            return Some(Err(e.into()));
        }
    }

    match FromRadio::decode(&buf[..]) {
        Ok(msg) => Some(Ok(msg)),
        Err(e) => Some(Err(io::Error::new(io::ErrorKind::InvalidData, e))),
    }
}

}
use meshtastic::{Message, protobufs::telemetry};

use std::convert::TryFrom;
use meshtastic::protobufs::{
    from_radio::PayloadVariant as FromRadioPayload,
    mesh_packet::PayloadVariant as MeshPayload,
    FromRadio, Data, PortNum,
};

#[derive(Debug, Clone, PartialEq)]
pub struct TextMessage {
    pub to: Option<String>,
    pub from: Option<String>,
    pub msg: String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum AppMessage {
    Telemetry(Telemetry),
    Position(Position),
    Text(TextMessage),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Position {
    pub latitude: f64,  // in degrees
    pub longitude: f64, // in degrees
    pub altitude: i32,  // in meters
    pub accuracy: u32,  // in meters
    pub speed: f32,     // in m/s
    pub heading: f32,   // in degrees
}

impl TryFrom<&[u8]> for Position {
    type Error = DecodeError;

    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        let proto_pos = meshtastic::protobufs::Position::decode(payload)
            .map_err(|_| DecodeError::PositionDecodeError)?;

                Ok(Self {
            latitude: proto_pos.latitude_i.map(|lat| lat as f64 / 1e7).unwrap_or(0.0),
            longitude: proto_pos.longitude_i.map(|lon| lon as f64 / 1e7).unwrap_or(0.0),
            altitude: proto_pos.altitude.unwrap_or(0),
            accuracy: proto_pos.gps_accuracy,
            speed: proto_pos.ground_speed.map(|speed| speed as f32 / 1e7).unwrap_or(0.0),
            heading: 0.0, // TODO: extract heading if available
        })
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Telemetry {
    Device {
        battery_level: Option<u32>,
        voltage: Option<f32>,
        uptime_seconds: Option<u32>,
    },
    Environment {
        temperature: Option<f32>,
        humidity: Option<f32>,
        pressure: Option<f32>,
    },
    Power {
        voltage: Option<f32>,
        current: Option<f32>,
    },
}


impl TryFrom<&[u8]> for Telemetry {
    type Error = DecodeError;

    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        use meshtastic::protobufs::{
            DeviceMetrics,
            EnvironmentMetrics,
            PowerMetrics,
        };

        // Try DeviceMetrics first
        if let Ok(dm) = DeviceMetrics::decode(payload) {
            return Ok(Telemetry::Device {
                battery_level: dm.battery_level,
                voltage: dm.voltage,
                uptime_seconds: dm.uptime_seconds,
            });
        }

        // Then EnvironmentMetrics
        if let Ok(env) = EnvironmentMetrics::decode(payload) {
            return Ok(Telemetry::Environment {
                temperature: env.temperature,
                humidity: env.relative_humidity,
                pressure: env.barometric_pressure,
            });
        }

        // Then PowerMetrics
        if let Ok(pwr) = PowerMetrics::decode(payload) {
            return Ok(Telemetry::Power {
                voltage: pwr.ch1_voltage,
                current: pwr.ch1_current,
            });
        }

log::warn!(
    "Telemetry decode failed: {}",
    payload.iter().map(|b| format!("{:02X}", b)).collect::<Vec<_>>().join(" ")
);

        Err(DecodeError::TelemetryDecodeError)
    }
}

/* 

impl TryFrom<&[u8]> for Telemetry {
    type Error = DecodeError;

    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {


        use meshtastic::protobufs::DeviceMetrics ;

        let proto_pos = DeviceMetrics::decode(payload)
            .map_err(|e| { 
                log::warn!("Failed to decode telemetry payload: {:?} {:?}", payload, e.to_string());
                
                DecodeError::TelemetryDecodeError
            })?;
        
        Ok(Self {
            battery_level: proto_pos.battery_level,
            voltage: proto_pos.voltage,
            uptime_seconds: proto_pos.uptime_seconds,
        })
    }
}
*/

#[derive(Debug, Clone)]
pub struct RadioMessage {
    pub node_id: u32,
    pub portnum: PortNum,
    pub app: AppMessage,
}

impl TryFrom<&FromRadio> for RadioMessage {
    type Error = DecodeError;

    fn try_from(msg: &FromRadio) -> Result<Self, Self::Error> {
        let node_id = msg.id;

        // Extract MeshPacket from FromRadio
        let mesh_packet = match &msg.payload_variant {
            Some(FromRadioPayload::Packet(p)) => p,
            _ => return Err(DecodeError::MeshPacketDecodeError),
        };

        // Extract the inner Data payload
        let data = match &mesh_packet.payload_variant {
            Some(MeshPayload::Decoded(d)) => d,
            _ => return Err(DecodeError::ExtractDecodeError),
        };

        let portnum = PortNum::from_i32(data.portnum).ok_or(DecodeError::CouldNotGetPortNum)?;

        // Decode based on the port type
        let payload = &data.payload[..];

        let app = match portnum {
            PortNum::TelemetryApp => {
                
                let telemetry = Telemetry::try_from(payload)?;
                AppMessage::Telemetry(telemetry)
            }
            PortNum::PositionApp => {
                let pos = Position::try_from(payload)?;
                AppMessage::Position(pos)
            }
            PortNum::TextMessageApp => {
                // For simplicity, decode payload as UTF-8 string; real implementation may parse structured fields
                let msg_str = String::from_utf8_lossy(payload).to_string();
                log::trace!("Decoded text message: {}", msg_str);
                let text_msg = TextMessage {
                    to: None,   // populate if your protocol supplies
                    from: None, // populate if your protocol supplies
                    msg: msg_str,
                };
                AppMessage::Text(text_msg)
            }
            _ => return Err(DecodeError::UnsupportedPort(portnum)),
        };

        Ok(Self {
            node_id,
            portnum,
            app,
        })
    }
}

/* 

fn extract_data(msg: &FromRadio) -> Result<(PortNum, &[u8]), DecodeError> {
    let packet = match &msg.payload_variant {
        Some(FromRadioPayload::Packet(p)) => p,
        _ => return Err(DecodeError::ExtractedData),
    };

    let data = match &packet.payload_variant {
        Some(MeshPayload::Decoded(d)) => d,
        _ => return Err(DecodeError::ExtractedData),
    };

    let portnum = PortNum::from_i32(data.portnum).ok_or(DecodeError::ExtractedData)?;

    Ok((portnum, &data.payload))
}

 */


#[derive(Debug, PartialEq)]
pub enum DecodeError {
    CouldNotGetPortNum,
    UnsupportedPort(PortNum),
    MeshPacketDecodeError,
    ExtractDecodeError,
    TelemetryAppError,
    TelemetryDecodeError,
    PositionDecodeError,
    PositionAppError,
    ExtractedData,
    LocalSystemMessage,
    //ProtobufDecodeError(prost::error::DecodeError),
}

#[cfg(test)]
mod tests {
    use std::env;

    use super::*;

    use meshtastic::protobufs::from_radio::PayloadVariant as FromRadioPayload;
    use meshtastic::protobufs::mesh_packet::PayloadVariant as MeshPayload;
    use meshtastic::protobufs::{Data, FromRadio, MeshPacket, PortNum};

    fn init_test_logging() {
        let _ = env_logger::builder()
            .is_test(true)
            .filter_level(log::LevelFilter::Debug)
            .try_init();
    }

    fn make_from_radio(portnum: PortNum) -> FromRadio {
        let data = Data {
            portnum: portnum as i32,
            payload: vec![1, 2, 3], // arbitrary, not decoded here
            want_response: false,
            dest: 0,
            source: 0,
            request_id: 0,
            reply_id: 0,
            emoji: 0,
            bitfield: None,
        };

        let packet = MeshPacket {
            from: 42,
            to: 0,
            channel: 0,
            id: 123,
            rx_time: 0,
            rx_snr: 0.0,
            hop_limit: 0,
            want_ack: false,
            priority: 0,
            rx_rssi: 0,
            delayed: 0,
            via_mqtt: false,
            hop_start: 0,
            public_key: vec![],
            pki_encrypted: false,
            next_hop: 0,
            relay_node: 0,
            tx_after: 0,
            transport_mechanism: 0,
            payload_variant: Some(MeshPayload::Decoded(data)),
        };

        FromRadio {
            id: 99,
            payload_variant: Some(FromRadioPayload::Packet(packet)),
        }
    }

    #[test]
    fn detects_telemetry_decode_error() {
        init_test_logging();

        let msg = make_from_radio(PortNum::TelemetryApp);
        let radio_msg = RadioMessage::try_from(&msg);
        assert!(radio_msg.is_err());
    }

    #[test]
    fn classifies_other_ports() {
        init_test_logging();
        let msg = make_from_radio(PortNum::TextMessageApp);
        let radio_msg = RadioMessage::try_from(&msg).unwrap();

        match radio_msg.app {
            AppMessage::Text(_) => {}
            _ => panic!("expected text message"),
        }
    }
    //use super::*;
    use meshtastic::Message;

    use meshtastic::protobufs::{DeviceMetrics, from_radio::PayloadVariant};

    #[test]
    fn decodes_telemetry_message() {
        init_test_logging();
        let metrics = DeviceMetrics {
            battery_level: Some(87),
            voltage: Some(4.12),
            uptime_seconds: Some(12345),
            ..Default::default()
        };

        let mut payload = Vec::new();
        metrics.encode(&mut payload).unwrap();

        let data = Data {
            portnum: PortNum::TelemetryApp as i32,
            payload,
            ..Default::default()
        };

        let packet = MeshPacket {
            payload_variant: Some(MeshPayload::Decoded(data)),
            ..Default::default()
        };

        let from_radio = FromRadio {
            id: 42,
            payload_variant: Some(PayloadVariant::Packet(packet)),
        };

        let msg = RadioMessage::try_from(&from_radio).unwrap();

        // match msg.app {
        //     AppMessage::Telemetry(dm) => {
        //         assert_eq!(dm.battery_level , Some(87));
        //     }
        //     _ => panic!("Expected telemetry"),
        // }
    }
}
use std::{
    fs::{File, OpenOptions},
    io::{self, Write},
    path::{Path, PathBuf},
    time::{SystemTime, UNIX_EPOCH},
};

const MAX_FILE_SIZE: u64 = 10 * 1024 * 1024; // 10 MB

pub struct RecordingStream {
    dir: PathBuf,
    current_file: File,
    current_size: u64,
    file_index: u64,
}



impl RecordingStream {
    pub fn new<P: AsRef<Path>>(dir: P) -> io::Result<Self> {
        std::fs::create_dir_all(&dir)?;

        let stream = Self {
            dir: dir.as_ref().to_path_buf(),
            current_file: Self::open_file(&dir, 0)?,
            current_size: 0,
            file_index: 0,
        };

        Ok(stream)
    }

    fn open_file<P: AsRef<Path>>(dir: P, index: u64) -> io::Result<File> {
        let filename = format!("meshtastic-recording-{:05}.bin", index);
        let path = dir.as_ref().join(filename);

        OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)
    }

    fn rotate_if_needed(&mut self, next_record_size: u64) -> io::Result<()> {
        if self.current_size + next_record_size <= MAX_FILE_SIZE {
            return Ok(());
        }

        self.file_index += 1;
        self.current_file = Self::open_file(&self.dir, self.file_index)?;
        self.current_size = 0;

        Ok(())
    }

    pub fn record(&mut self, raw_payload: &[u8]) -> io::Result<()> {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("time went backwards")
            .as_secs();

        let payload_len = raw_payload.len() as u32;

        let record_size =
            8 + // timestamp
            4 + // payload_len
            payload_len as u64;

        self.rotate_if_needed(record_size)?;

        self.current_file.write_all(&timestamp.to_le_bytes())?;
        self.current_file.write_all(&payload_len.to_le_bytes())?;
        self.current_file.write_all(raw_payload)?;
	self.current_file.flush()?;

        self.current_size += record_size;

        Ok(())
    }

    pub fn flush(&mut self) -> io::Result<()> {
        self.current_file.flush()
    }
}

